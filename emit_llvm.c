#include <stdio.h>
#include <stdint.h>
#include <stdarg.h>
#include <stdlib.h>
#include "llvm_config.h"

/*
 * Support functions
 */

/* Print a string to the output file. */
static void w(const char *s, ...)
{
	va_list ap;
	va_start(ap, s);
	vprintf(s, ap);
	va_end(ap);
}

/* Scream when you see a bug! */
#define EMIT_PANIC(_s)				\
	fprintf(stderr, "%s:%d : %s\n", 	\
		__FILE__, __LINE__, (_s));	\
	exit(-1);

/* Out of memory. */
static void emit_oom(void)
{
	fprintf(stderr, "Out of memory!\n");
}

/* Table support:
 * LLVM assembler does not allow to specify a data segment 
 * the way that machine-specific untyped assembler do.
 * 
 * In order to create the LLOWL tables, this mapper's 
 * approach is to scan for the whole file, collecting
 * information about the LLOWL program table, and
 * dump it later in a form of packed structure.
 *
 * Labels are stored as constants retaining the value of
 * the offset in this table. LAA X, C handles this special
 * case.
 */
struct tble {
	int type;
	union {
		char 		ch;
		char 		*str;
		uintptr_t	num;
	} u;
	struct tble *next;
};

enum {
	TBL_CH,
	TBL_STR,
	TBL_NUM,
};

struct tble *last, *tbl = NULL; 
unsigned long tbl_size = 0;

void
tbl_append(struct tble *ptr)
{
	if ( tbl == NULL )
		tbl = last = ptr;
	else {
		last->next = ptr;
		last = ptr;
	}

	/* Collect Table Size. */
	switch(ptr->type) {
	case TBL_CH:
		tbl_size++;
		break;
	case TBL_STR:
		tbl_size += strlen(ptr->u.str);
		break;
	case TBL_NUM:
		tbl_size += LLVM_PTRSIZE / 8;
		break;
	default:
		EMIT_PANIC("Wrong TBL Type!");
	}
}

void
tbl_dump(void)
{
	struct tble *ptr;

	/* The LLOWL Table is represented in LLVM as a packed structure.
	 * We scan the table two times, first time to get the types,
	 * second one to the values. */

	w("\n\n;\n; LLOWL Table\n;\n");
	w("@LLOWLTAB = global ");

	/* First pass. Define the structure. */
	w(" < { ");
	ptr = tbl;
	while ( ptr != NULL ) {
		if ( ptr != tbl ) w(", ");
		switch (ptr->type)
		{
		case TBL_CH:
			w("i8");
			break;
		case TBL_NUM:
			w("%%LLNUM");
			break;
		case TBL_STR:
			w("[ %d x i8 ]", strlen(ptr->u.str));
			break;
		default:
			EMIT_PANIC("Wrong TBL Type!");
		}
		ptr = ptr->next;
	}
	w(" } > ");

	/* Second pass. Write the initializer. */
	w("< {  ");
	ptr = tbl;
	while ( ptr != NULL ) {
		if ( ptr != tbl ) w(", ");
		switch (ptr->type)
		{
		case TBL_CH:
			w("i8 %d", ptr->u.ch);
			break;
		case TBL_NUM:
			w("%%LLNUM %d", ptr->u.num);
			break;
		case TBL_STR:
			w("[ %d x i8 ] c\"%s\"", strlen(ptr->u.str),
						   ptr->u.str);
			break;
		default:
			EMIT_PANIC("Wrong TBL Type!");
		}
		ptr = ptr->next;
	}
	w(" } >; \n ");
}

/*
 * Emitter setup
 */

/* Initialization. */
void
emitter_init(void)
{
	/* Print some basic banner. */
	w(";\n; This file has been autogenerated by LLOWL-LLVM mapper.\n");
	w(";\n\n\n");
	/* Define basic types. */
	w("; Basic types definitions.\n");
	w("%%LLNUM = type i%d; Numerical is %d bits\n",
	  LLVM_PTRSIZE, LLVM_PTRSIZE);
	w("\n\n");
}

/* Finalization. */
void
emitter_fini(void)
{
	/* Dump the LLOWL table. */
	tbl_dump();
}


/*
 * EMITTER FUNCTIONS START HERE.
 */


void emit_table_label(char *lbl)
{
	/* Table labels are simple constants whose value is
	 * the offset from the table start. Even if we haven't dumped
	 * the table still, the current offset can be found in current
	 * tbl_size value. */
	w("@%s = constant %%LLNUM %ld;    [%s]\n", lbl, tbl_size, lbl);
}


void emit_label()
{
}


void emit_eol()
{
	w("\n");
}


void emit_dcl(char *var)
{

	w("@%s = global %%LLNUM zeroinitializer;    DCL %s\n", var, var);
}


void emit_equ(char *arg1, char *arg2)
{
	printf("@%s = alias %%LLNUM* @%s;    EQU %s %s\n",
	       arg1, arg2, arg1, arg2);
}


void emit_ident()
{
	/* IDENT handled in the parser. */
}


void emit_con(uintptr_t num)
{
	struct tble *tble;
	tble = malloc(sizeof(struct tble));
	if ( tble == NULL )
		emit_oom();
	tble->type = TBL_NUM;
	tble->u.num = num;
	tbl_append(tble);
}


void emit_nch(char c)
{
	struct tble *tble;
	tble = malloc(sizeof(struct tble));
	if ( tble == NULL )
		emit_oom();
	tble->type = TBL_CH;
	tble->u.ch = c;
	tbl_append(tble);
}


void emit_str(char *str)
{
	struct tble *tble;
	tble = malloc(sizeof(struct tble));
	if ( tble == NULL )
		emit_oom();
	tble->type = TBL_STR;
	tble->u.str = str;
	tbl_append(tble);
}


void emit_lav()
{
}


void emit_lbv()
{
}


void emit_lal()
{
}


void emit_lcn()
{
}


void emit_lam()
{
}


void emit_lcm()
{
}


void emit_lai()
{
}


void emit_lci()
{
}


void emit_laa()
{
}


void emit_stv()
{
}


void emit_sti()
{
}


void emit_clear()
{
}


void emit_aav()
{
}


void emit_abv()
{
}


void emit_aal()
{
}


void emit_sav()
{
}


void emit_sbv()
{
}


void emit_sal()
{
}


void emit_sbl()
{
}


void emit_multl()
{
}


void emit_bump()
{
}


void emit_andv()
{
}


void emit_andl()
{
}


void emit_cav()
{
}


void emit_cal()
{
}


void emit_ccl()
{
}


void emit_cai()
{
}


void emit_cci()
{
}


void emit_subr()
{
}


void emit_exit()
{
}


void emit_gosub()
{
}


void emit_goadd()
{
}


void emit_css()
{
}


void emit_go()
{
}


void emit_goeq()
{
}


void emit_gone()
{
}


void emit_goge()
{
}


void emit_gogr()
{
}


void emit_gole()
{
}


void emit_golt()
{
}


void emit_gopc()
{
}


void emit_gond()
{
}


void emit_fstk()
{
}


void emit_bstk()
{
}


void emit_cfstk()
{
}


void emit_unstk()
{
}


void emit_fmove()
{
}


void emit_bmove()
{
}


void emit_mess()
{
}


void emit_nb(char *comment)
{
	w("; %s\n", comment);
}


void emit_prgst()
{
}


void emit_prgen()
{
}


void emit_align()
{
}


