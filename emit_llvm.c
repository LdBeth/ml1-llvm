#include <stdio.h>
#include <stdint.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include "llvm_config.h"

/*
 * Support functions
 */

/* Print a string to the output file. */
static void w(const char *s, ...)
{
	va_list ap;
	va_start(ap, s);
	vprintf(s, ap);
	va_end(ap);
}

/* Scream when you see a bug! */
#define EMIT_PANIC(_s)				\
	fprintf(stderr, "%s:%d : %s\n", 	\
		__FILE__, __LINE__, (_s));	\
	exit(-1);

/* Out of memory. */
static void emit_oom(void)
{
	fprintf(stderr, "Out of memory!\n");
}

/*
 * LLVM Functions and separation between code and data:
 *
 * As code in LLVM assembler must be included into functions,
 * we need to realize when we start generating code so that
 * we can create one big function that contains all the code.
 *
 * By making the following assumptions,
 *
 * - LOWL programs will define data section in two separate
 *   stages;
 * - Data are defined before code.
 * - the first opcode will tagged by a label (usually it's
 * [BEGIN], but this is irrelevant to us);
 *
 * this emitter creates a function at the first call of
 * emit_label(), which gets called only when a label is
 * associated with an instruction.
 */
int function_created = 0;

/*
 * Compare and condition codes.
 *
 * Global version number for the SSA variable
 * keeping the compare result.
 */
int cmp_cnt = 0;

/* Table support:
 * LLVM assembler does not allow to specify a data segment
 * the way that machine-specific untyped assembler do.
 *
 * In order to create the LOWL tables, this mapper's
 * approach is to scan for the whole file, collecting
 * information about the LOWL program table, and
 * dump it later in a form of packed structure.
 *
 * Labels are stored as constants retaining the value of
 * the offset in this table. LAA X, C handles this special
 * case.
 */
struct tble {
	int type;
	union {
		char 		ch;
		char 		*str;
		uintptr_t	num;
	} u;
	struct tble *next;
};

enum {
	TBL_CH,
	TBL_STR,
	TBL_NUM,
};

struct tble *last, *tbl = NULL;
unsigned long tbl_size = 0;

void
tbl_append(struct tble *ptr)
{
	if ( tbl == NULL )
		tbl = last = ptr;
	else {
		last->next = ptr;
		last = ptr;
	}

	/* Collect Table Size. */
	switch(ptr->type) {
	case TBL_CH:
		tbl_size++;
		break;
	case TBL_STR:
		tbl_size += strlen(ptr->u.str);
		break;
	case TBL_NUM:
		tbl_size += LLVM_PTRSIZE / 8;
		break;
	default:
		EMIT_PANIC("Wrong TBL Type!");
	}
}

void
tbl_dump(void)
{
	struct tble *ptr;

	/* The LOWL Table is represented in LLVM as a packed structure.
	 * We scan the table two times, first time to get the types,
	 * second one to the values. */

	w("\n\n;\n; LOWL Table\n;\n");
	w("@LOWLTAB = global ");

	/* First pass. Define the structure. */
	w(" < { ");
	ptr = tbl;
	while ( ptr != NULL ) {
		if ( ptr != tbl ) w(", ");
		switch (ptr->type)
		{
		case TBL_CH:
			w("i8");
			break;
		case TBL_NUM:
			w("%%LLNUM");
			break;
		case TBL_STR:
			w("[ %d x i8 ]", strlen(ptr->u.str));
			break;
		default:
			EMIT_PANIC("Wrong TBL Type!");
		}
		ptr = ptr->next;
	}
	w(" } > ");

	/* Second pass. Write the initializer. */
	w("< {  ");
	ptr = tbl;
	while ( ptr != NULL ) {
		if ( ptr != tbl ) w(", ");
		switch (ptr->type)
		{
		case TBL_CH:
			w("i8 %d", ptr->u.ch);
			break;
		case TBL_NUM:
			w("%%LLNUM %d", ptr->u.num);
			break;
		case TBL_STR:
			w("[ %d x i8 ] c\"%s\"", strlen(ptr->u.str),
						   ptr->u.str);
			break;
		default:
			EMIT_PANIC("Wrong TBL Type!");
		}
		ptr = ptr->next;
	}
	w(" } >; \n ");
}

/*
 * Implicit data declaration.
 * Strings used in MESS are implicit in LOWL but in LLVM must
 * be declared outside of the function. Save them in a list and
 * declare later.
 */
struct strdecl {
	int id;
	char *str;
	struct strdecl *next;
} *strdecls = NULL;
int strings = 0;

int
str_declare(char *str)
{
	struct strdecl *ptr = malloc(sizeof(struct strdecl));
	ptr->str = str;
	ptr->id = strings;
	ptr->next = strdecls;
	strdecls = ptr;
	return strings++;
}

void
str_dump()
{
	struct strdecl *ptr = strdecls;
	while ( ptr != NULL )
	{
		w("@STR%d = internal constant [ %d x i8 ] c\"%s\\00\";\n",
		  ptr->id, strlen(ptr->str)+1, ptr->str);
		ptr = ptr->next;
	}
}

/*
 * Emitter setup
 */

/* Initialization. */
void
emitter_init(void)
{
	/* Print some basic banner. */
	w(";\n; This file has been autogenerated by LOWL-LLVM mapper.\n");
	w(";\n\n\n");
	/* Define basic types. */
	w("; Basic types definitions.\n");
	w("%%LLNUM = type i%d; Numerical is %d bits\n",
	  LLVM_PTRSIZE, LLVM_PTRSIZE);
	w("\n");
	/* Declare LOWL registers. */
	w("; LOWL Registers.\n");
	w("@A_REG = internal global %%LLNUM 0;\n");
	w("@B_REG = internal global %%LLNUM 0;\n");
	w("@C_REG = internal global i8 0;\n");
	w("\n");
	w("; External declarations.\n");
	w("declare i32 @llowl_puts(i8*);\n");
	w("\n\n");
}

/* Finalization. */
void
emitter_fini(void)
{
	/* Terminate and close the LLVM function. */
	w("\n; End of LOWL code\nret void;\n}\n\n");

	/* Declare MESS strings. */
	str_dump();

	/* Dump the LOWL table. */
	tbl_dump();
}


/*
 * EMITTER FUNCTIONS START HERE.
 */


void emit_table_label(char *lbl)
{
	/* Table labels are simple constants whose value is
	 * the offset from the table start. Even if we haven't dumped
	 * the table still, the current offset can be found in current
	 * tbl_size value. */
	w("@%s = constant %%LLNUM %ld;    [%s]\n", lbl, tbl_size, lbl);
}


void emit_label(char *lbl)
{
	/* See comment before function_created. */
	if ( !function_created ) {
		w("\n;\n; LOWL LLVM function\n");
		w("define void @LLOWL_main() {\n");
		w("br label %%BEGIN;   Jump to BEGIN\n");
		w("\n");
		function_created = 1;
	} else {
		/* LLVM assembler can't fall through labels,
		 * as internally it thinks in basic blocks.
		 * When adding a label in a middle of some
		 * code, add an inconditional branch to it
		 * so that the two basic blocks are
		 * continguous. */
		w("br label %%%s\n\n", lbl);
	}
	w("%s:\n", lbl);
}


void emit_eol()
{
	w("\n");
}


void emit_dcl(char *var)
{

	w("@%s = global %%LLNUM zeroinitializer;    DCL %s\n", var, var);
}


void emit_equ(char *arg1, char *arg2)
{
	printf("@%s = alias %%LLNUM* @%s;    EQU %s %s\n",
	       arg1, arg2, arg1, arg2);
}


void emit_ident()
{
	/* IDENT handled in the parser. */
}


void emit_con(uintptr_t num)
{
	struct tble *tble;
	tble = malloc(sizeof(struct tble));
	if ( tble == NULL )
		emit_oom();
	tble->type = TBL_NUM;
	tble->u.num = num;
	tbl_append(tble);
}


void emit_nch(char c)
{
	struct tble *tble;
	tble = malloc(sizeof(struct tble));
	if ( tble == NULL )
		emit_oom();
	tble->type = TBL_CH;
	tble->u.ch = c;
	tbl_append(tble);
}


void emit_str(char *str)
{
	struct tble *tble;
	tble = malloc(sizeof(struct tble));
	if ( tble == NULL )
		emit_oom();
	tble->type = TBL_STR;
	tble->u.str = str;
	tbl_append(tble);
}


void emit_lav(char *v, char rx)
{
	static int lav_cnt = 0;
	w("%%lav.%d = load %%LLNUM* @%s;    LAV %s, %c\n", lav_cnt, v, v, rx);
	w("store %%LLNUM %%lav.%d, %%LLNUM* @A_REG;\n", lav_cnt);
	lav_cnt++;
}

void emit_lbv(char *v)
{
	static int lbv_cnt = 0;
	w("%%lbv.%d = load %%LLNUM* @%s;    LBV %s\n", lbv_cnt, v, v);
	w("store %%LLNUM %%lbv.%d, %%LLNUM* @B_REG;\n", lbv_cnt);
	lbv_cnt++;
}


void emit_lal(intptr_t nof)
{
	w("store %%LLNUM %ld, %%LLNUM* @A_REG;    LAL %ld\n",
	  nof, nof);
}


void emit_lcn(char cn)
{
	w("store i8 %d, i8* @C_REG;    LCN '%d'\n", cn, cn);
}


void emit_lam(intptr_t nof)
{
	static int lam_cnt = 0;
	w("%%lam.%d = load %%LLNUM* @B_REG;    LAM %d\n", lam_cnt, nof);
	w("%%lam.2.%d = add %%LLNUM %%lam.%d, %d\n", lam_cnt, lam_cnt, nof);
	w("%%lam.3.%d = inttoptr %%LLNUM %%lam.2.%d to %%LLNUM*\n",
	  lam_cnt, lam_cnt);
	w("%%lam.4.%d = load %%LLNUM* %%lam.3.%d\n", lam_cnt, lam_cnt);
	w("store %%LLNUM %%lam.4.%d, %%LLNUM* @A_REG\n", lam_cnt);
	w("store %%LLNUM %%lam.2.%d, %%LLNUM* @B_REG\n", lam_cnt);
	lam_cnt++;
}


void emit_lcm()
{
}


void emit_lai()
{
}


void emit_lci()
{
}


void emit_laa()
{
}


void emit_stv(char *v, char px)
{
	static int stv_cnt = 0;
	w("%%stv.%d = load %%LLNUM* @A_REG;    STV %s, %c\n", stv_cnt, v, px);
	w("store %%LLNUM %%stv.%d, %%LLNUM* @%s\n", stv_cnt, v);
	stv_cnt++;
}


void emit_sti()
{
}


void emit_clear(char *v)
{
	w("store %%LLNUM 0, %%LLNUM* @%s;    CLEAR %s\n", v, v);
}


void emit_aav(char *v)
{
	static int aav_cnt = 0;
	w("%%aav.%d = load %%LLNUM* @A_REG;    ABV %s\n", aav_cnt, v);
	w("%%aav.2.%d = load %%LLNUM* @%s\n", aav_cnt, v);
	w("%%aav.3.%d = add %%LLNUM %%aav.%d, %%aav.2.%d\n",
	  aav_cnt, aav_cnt, aav_cnt);
	w("store %%LLNUM %%aav.3.%d, %%LLNUM* @A_REG\n", aav_cnt);
	aav_cnt++;
}


void emit_abv(char *v)
{
	static cnt = 0;
	w("%%abv.%d = load %%LLNUM* @B_REG;    AAV %s\n", cnt, v);
	w("%%abv.2.%d = load %%LLNUM* @%s\n", cnt, v);
	w("%%abv.3.%d = add %%LLNUM %%abv.%d, %%abv.2.%d\n",
	  cnt, cnt, cnt);
	w("store %%LLNUM %%abv.3.%d, %%LLNUM* @B_REG\n", cnt);
	cnt++;
}


void emit_aal(intptr_t nof)
{
	static cnt = 0;
	w("%%aal.%d = load %%LLNUM* @A_REG;    AAL %d\n", cnt, nof);
	w("%%aal.2.%d = add %%LLNUM %%aal.%d, %d\n", cnt, cnt, nof);
	w("store %%LLNUM %%aal.2.%d, %%LLNUM* @A_REG\n", cnt);
	cnt++;
}


void emit_sav(char *v)
{
	static int sav_cnt = 0;
	w("%%sav.%d = load %%LLNUM* @A_REG;    SAV %s\n", sav_cnt, v);
	w("%%sav.2.%d = load %%LLNUM* @%s\n", sav_cnt, v);
	w("%%sav.3.%d = sub %%LLNUM %%sav.%d, %%sav.2.%d\n",
	  sav_cnt, sav_cnt, sav_cnt);
	w("store %%LLNUM %%sav.3.%d, %%LLNUM* @A_REG\n", sav_cnt);
	sav_cnt++;
}


void emit_sbv(char *v)
{
	static int cnt = 0;
	w("%%sbv.%d = load %%LLNUM* @B_REG;    SBV %s\n", cnt, v);
	w("%%sbv.2.%d = load %%LLNUM* @%s\n", cnt, v);
	w("%%sbv.3.%d = sub %%LLNUM %%sbv.%d, %%sbv.2.%d\n",
	  cnt, cnt, cnt);
	w("store %%LLNUM %%sbv.3.%d, %%LLNUM* @A_REG\n", cnt);
	cnt++;
}


void emit_sal(intptr_t nof)
{
	static int sal_cnt = 0;
	w("%%sal.%d = load %%LLNUM* @A_REG;    SAL %d\n", sal_cnt, nof);
	w("%%sal.3.%d = sub %%LLNUM %%sal.%d, %d\n",
	  sal_cnt, sal_cnt, nof);
	w("store %%LLNUM %%sal.3.%d, %%LLNUM* @A_REG\n", sal_cnt);
	sal_cnt++;
}


void emit_sbl()
{
}


void emit_multl()
{
}


void emit_bump()
{
}


void emit_andv()
{
}


void emit_andl()
{
}


void emit_cav()
{
}


void emit_cal(intptr_t nof)
{
	static int cal_cnt = 0;
	cmp_cnt++; /* Update version. */
	w("%%cal.%d = load %%LLNUM* @A_REG;   CAL %ld\n", cal_cnt, nof);
	w("%%cmp.%d = sub %%LLNUM %%cal.%d, %ld\n", cmp_cnt, cal_cnt, nof);
	cal_cnt++;
}


void emit_ccl()
{
}


void emit_cai()
{
}


void emit_cci()
{
}


void emit_subr()
{
}


void emit_exit()
{
}


void emit_gosub()
{
}


void emit_goadd()
{
}


void emit_css()
{
}


void emit_go(char *lbl, intptr_t dist, char ex, char ctx)
{
	w("br label %%%s;    GO %s, %d, %c, %c\n",
	  lbl, lbl, dist, ex, ctx);
}


void emit_goeq(char *lbl, intptr_t dist, char ex, char ctx)
{
	static int goeq_cnt = 0;
	w("%%goeq.%d = icmp eq %%LLNUM %%cmp.%d, 0;     GOEQ %s, %ld, %c, %c\n",
	  goeq_cnt, cmp_cnt, lbl, dist, ex, ctx);
	w("br i1 %%goeq.%d, label %%%s, label %%goeq_false.%d;\n",
	  goeq_cnt, lbl, goeq_cnt);
	w("goeq_false.%d:\n", goeq_cnt);
	goeq_cnt++;
}


void emit_gone(char *lbl, intptr_t dist, char ex, char ctx)
{
	static int gone_cnt = 0;
	w("%%gone.%d = icmp ne %%LLNUM %%cmp.%d, 0;     GONE %s, %ld, %c, %c\n",
	  gone_cnt, cmp_cnt, lbl, dist, ex, ctx);
	w("br i1 %%gone.%d, label %%%s, label %%gone_false.%d;\n",
	  gone_cnt, lbl, gone_cnt);
	w("gone_false.%d:\n", gone_cnt);
	gone_cnt++;
}


void emit_goge(char *lbl, intptr_t dist, char ex, char ctx)
{
	static int cnt = 0;
	w("%%goge.%d = icmp sge %%LLNUM %%cmp.%d, 0;    GOGE %s, %ld, %c, %c\n",
	  cnt, cmp_cnt, lbl, dist, ex, ctx);
	w("br i1 %%goge.%d, label %%%s, label %%goge_false.%d\n",
	  cnt, lbl, cnt);
	w("goge_false.%d:\n", cnt);
	cnt++;
}


void emit_gogr(char *lbl, intptr_t dist, char ex, char ctx)
{

	static int cnt = 0;
	w("%%gogr.%d = icmp sgt %%LLNUM %%cmp.%d, 0;    GOGR %s, %ld, %c, %c\n",
	  cnt, cmp_cnt, lbl, dist, ex, ctx);
	w("br i1 %%gogr.%d, label %%%s, label %%gogr_false.%d\n",
	  cnt, lbl, cnt);
	w("gogr_false.%d:\n", cnt);
	cnt++;
}


void emit_gole(char *lbl, intptr_t dist, char ex, char ctx)
{
	static int cnt = 0;
	w("%%gole.%d = icmp sle %%LLNUM %%cmp.%d, 0;    GOLE %s, %ld, %c, %c\n",
	  cnt, cmp_cnt, lbl, dist, ex, ctx);
	w("br i1 %%gole.%d, label %%%s, label %%gole_false.%d\n",
	  cnt, lbl, cnt);
	w("gole_false.%d:\n", cnt);
	cnt++;
}


void emit_golt(char *lbl, intptr_t dist, char ex, char ctx)
{
	static int cnt = 0;
	w("%%golt.%d = icmp slt %%LLNUM %%cmp.%d, 0;    GOLT %s, %ld, %c, %c\n",
	  cnt, cmp_cnt, lbl, dist, ex, ctx);
	w("br i1 %%golt.%d, label %%%s, label %%golt_false.%d\n",
	  cnt, lbl, cnt);
	w("golt_false.%d:\n", cnt);
	cnt++;
}


void emit_gopc()
{
}


void emit_gond()
{
}


void emit_fstk()
{
}


void emit_bstk()
{
}


void emit_cfstk()
{
}


void emit_unstk()
{
}


void emit_fmove()
{
}


void emit_bmove()
{
}


void emit_mess(char *mess)
{
	int strid;

	/* Save string for later declaration. */
	strid = str_declare(mess);
	/* Get a pointer to the string with proper cast. */
	w("%%putsptr.%d = getelementptr [ %d x i8 ]* @STR%d, i64 0, i64 0\n",
	  strid, strlen(mess) + 1, strid);
	/* And call the function. */
	w("call i32 @llowl_puts(i8* %%putsptr.%d)\n", strid);
}


void emit_nb(char *comment)
{
	w("; %s\n", comment);
}


void emit_prgst()
{
}


void emit_prgen()
{
}


void emit_align()
{
}


